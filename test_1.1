// C# UI Automation Console Application - Final Refactoring
// Note: This requires references to UIAutomationClient, UIAutomationTypes, and System.Diagnostics.Process.
// For a .NET Core/5+ project, add the `UIAComWrapper` NuGet package.

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using System.Windows.Automation;

namespace FinalUiAutomation
{
    // =================================================================================
    // 1. IMPROVEMENT: EXTERNALIZED CONFIGURATION
    // Settings are centralized to avoid hardcoded values ("magic strings").
    // =================================================================================
    public static class AppSettings
    {
        public static ProcessSettings Process { get; } = new ProcessSettings();
        public static AutomationSettings Automation { get; } = new AutomationSettings();
    }

    public class ProcessSettings
    {
        public string ProcessName { get; set; } = "notepad";
        public string MainWindowTitle { get; set; } = "Untitled - Notepad";
    }

    public class AutomationSettings
    {
        public int DefaultTimeoutMs { get; set; } = 5000;
        public int RetryAttempts { get; set; } = 3;
        public int RetryDelayMs { get; set; } = 500;
        public Dictionary<string, string> UiElementIdentifiers { get; } = new Dictionary<string, string>
        {
            { "Editor", "15" } // Key: "Editor", Value: AutomationId for Notepad's main text area.
        };
    }

    // A simple logger interface (can be replaced with a real logging library like Serilog/NLog)
    public interface ILogger
    {
        void Info(string message);
        void Warn(string message);
        void Error(string message, Exception ex = null);
    }
    
    public class ConsoleLogger : ILogger
    {
        public void Info(string message) => Log(message, ConsoleColor.White);
        public void Warn(string message) => Log($"[WARN] {message}", ConsoleColor.Yellow);
        public void Error(string message, Exception ex = null)
        {
            Log($"[ERROR] {message}", ConsoleColor.Red);
            if (ex != null) Console.Error.WriteLine(ex.ToString());
        }
        private void Log(string message, ConsoleColor color)
        {
            Console.ForegroundColor = color;
            Console.WriteLine(message);
            Console.ResetColor();
        }
    }

    public class AutomationService
    {
        private readonly ILogger _logger;
        private AutomationPropertyChangedEventHandler _textChangedHandler;
        
        // =================================================================================
        // 4. IMPROVEMENT: UI ELEMENT CACHING
        // A cache to store AutomationElement references, avoiding repeated, slow UI tree searches.
        // =================================================================================
        private readonly Dictionary<string, AutomationElement> _elementCache = new Dictionary<string, AutomationElement>();

        public AutomationService(ILogger logger)
        {
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        }

        public void InitializeElementCache(AutomationElement parentWindow)
        {
            _logger.Info("Initializing UI element cache...");
            _elementCache.Clear();
            foreach (var elementDef in AppSettings.Automation.UiElementIdentifiers)
            {
                var element = parentWindow.FindFirst(TreeScope.Descendants,
                    new PropertyCondition(AutomationElement.AutomationIdProperty, elementDef.Value));
                
                if (element != null)
                {
                    _elementCache[elementDef.Key] = element;
                    _logger.Info($"  - Cached '{elementDef.Key}' successfully.");
                }
                else
                {
                    _logger.Warn($"  - Could not find and cache element '{elementDef.Key}' with AutomationId '{elementDef.Value}'.");
                }
            }
        }
        
        public AutomationElement GetCachedElement(string key)
        {
            if (_elementCache.TryGetValue(key, out var element))
            {
                return element;
            }
            throw new KeyNotFoundException($"Element with key '{key}' was not found in the cache.");
        }

        // =================================================================================
        // 3. IMPROVEMENT: ROBUST PROCESS VALIDATION
        // Finds a process and validates that it has a main window handle and is responsive.
        // =================================================================================
        public Process FindValidatedProcess()
        {
            _logger.Info($"Searching for process: '{AppSettings.Process.ProcessName}'...");
            var processes = Process.GetProcessesByName(AppSettings.Process.ProcessName);
            var targetProcess = processes.FirstOrDefault(p => p.MainWindowHandle != IntPtr.Zero && p.Responding);

            if (targetProcess == null) _logger.Warn("No running and responsive process found.");
            else _logger.Info($"Validated process found with ID: {targetProcess.Id}");
            
            return targetProcess;
        }

        public async Task<AutomationElement> WaitForWindowByTitleAsync(TimeSpan timeout)
        {
            // Implementation omitted for brevity - same as previous version
            _logger.Info($"Waiting for window with title containing '{AppSettings.Process.MainWindowTitle}'...");
            // ... (event subscription logic)
            // This part is conceptually the same and would use TaskCompletionSource
            // For this example, we'll assume it returns a valid element on success.
            var tcs = new TaskCompletionSource<AutomationElement>();
            // ...
            // In a real scenario, this would be fully implemented.
            // For now, we simulate finding it after a short delay for demonstration.
            await Task.Delay(1000); 
            var desktop = AutomationElement.RootElement;
            var window = desktop.FindFirst(TreeScope.Children, new PropertyCondition(AutomationElement.NameProperty, AppSettings.Process.MainWindowTitle, PropertyConditionFlags.IgnoreCase));
            if(window != null) tcs.TrySetResult(window);
            else tcs.TrySetCanceled();
            
            return await tcs.Task;
        }

        // =================================================================================
        // 2. IMPROVEMENT: EVENT-DRIVEN UI MONITORING
        // Highly efficient event-based listener that avoids polling.
        // =================================================================================
        public void RegisterTextChangeMonitor(AutomationElement element, Action<string> onTextChangedCallback)
        {
            _textChangedHandler = (sender, e) =>
            {
                if (e.Property == ValuePattern.ValueProperty)
                {
                    onTextChangedCallback?.Invoke(e.NewValue as string);
                }
            };
            Automation.AddAutomationPropertyChangedEventHandler(
                element, TreeScope.Element, _textChangedHandler, ValuePattern.ValueProperty);
            _logger.Info("Successfully registered text change event handler.");
        }

        public void UnregisterTextChangeMonitor(AutomationElement element)
        {
            if (_textChangedHandler != null && element != null)
            {
                Automation.RemoveAutomationPropertyChangedEventHandler(element, _textChangedHandler);
                _textChangedHandler = null;
                _logger.Info("Unregistered text change event handler.");
            }
        }
        
        // =================================================================================
        // 5. IMPROVEMENT: ROBUST TEXT EXTRACTION
        // Tries multiple patterns to get text and logs failures instead of returning empty strings.
        // =================================================================================
        public string GetElementText(AutomationElement element)
        {
            if (element == null) return null;

            try
            {
                // Try with ValuePattern (most common for edit controls)
                if (element.TryGetCurrentPattern(ValuePattern.Pattern, out var valuePattern))
                {
                    return ((ValuePattern)valuePattern).Current.Value;
                }

                // Try with TextPattern (used by text containers)
                if (element.TryGetCurrentPattern(TextPattern.Pattern, out var textPattern))
                {
                    return ((TextPattern)textPattern).DocumentRange.GetText(-1).TrimEnd('\\r');
                }
                
                // Fallback to LegacyIAccessiblePattern (for older applications)
                if (element.TryGetCurrentPattern(LegacyIAccessiblePattern.Pattern, out var legacyPattern))
                {
                    return ((LegacyIAccessiblePattern)legacyPattern).Current.Value;
                }

                _logger.Warn($"Could not get text from element '{element.Current.Name}'. No supported pattern (Value, Text, LegacyIAccessible) was found.");
                return string.Empty;
            }
            catch (Exception ex)
            {
                _logger.Error($"An unexpected error occurred while trying to get text from element '{element.Current.Name}'.", ex);
                return null;
            }
        }
    }

    public static class Program
    {
        private static AutomationService _automationService;
        private static AutomationElement _editorElement;

        public static async Task Main(string[] args)
        {
            var logger = new ConsoleLogger();
            _automationService = new AutomationService(logger);
            Process notepadProcess = null;

            try
            {
                // Step 1: Find or start the Notepad process
                notepadProcess = _automationService.FindValidatedProcess();
                AutomationElement mainWindowElement;

                if (notepadProcess == null)
                {
                    logger.Info("Notepad is not running. Starting a new instance...");
                    notepadProcess = Process.Start(new ProcessStartInfo(AppSettings.Process.ProcessName));
                    await Task.Delay(500); // Give it time to start
                    notepadProcess.Refresh();
                    mainWindowElement = AutomationElement.FromHandle(notepadProcess.MainWindowHandle);
                }
                else
                {
                    logger.Info("Notepad is already running. Attaching to existing instance.");
                    mainWindowElement = AutomationElement.FromHandle(notepadProcess.MainWindowHandle);
                }
                
                // Step 2: Initialize the cache to find and store key UI elements
                _automationService.InitializeElementCache(mainWindowElement);
                
                // Step 3: Get the editor element from the cache
                _editorElement = _automationService.GetCachedElement("Editor");

                // Step 4: Register the event-driven monitor.
                _automationService.RegisterTextChangeMonitor(_editorElement, OnNotepadTextChanged);
                
                // Demonstrate reading text from the element
                string initialText = _automationService.GetElementText(_editorElement);
                logger.Info($"Initial editor text: \"{initialText}\"");

                // Step 5: Keep the application alive to listen for events
                logger.Info("\nâœ… Automation is now in event-listening mode.");
                Console.WriteLine("   Try typing or pasting text into the Notepad window.");
                Console.WriteLine("   Press any key in this console to exit.");
                Console.ReadKey();
            }
            catch (Exception ex)
            {
                logger.Error("An unhandled error occurred in the main execution block.", ex);
            }
            finally
            {
                // Step 6: Clean up resources
                if (_automationService != null && _editorElement != null)
                {
                    _automationService.UnregisterTextChangeMonitor(_editorElement);
                }
                if (notepadProcess != null && !notepadProcess.HasExited)
                {
                    logger.Info("Closing Notepad...");
                    notepadProcess.Kill();
                }
            }
        }

        // Callback method executed by the event handler in AutomationService
        private static void OnNotepadTextChanged(string newText)
        {
            Console.ForegroundColor = ConsoleColor.Cyan;
            Console.WriteLine($"\n[EVENT] Notepad text changed at {DateTime.Now:HH:mm:ss}");
            Console.ResetColor();
            Console.WriteLine($"--> New Content: \"{newText}\"");
            Console.WriteLine("--------------------------------------------------");
        }
    }
}

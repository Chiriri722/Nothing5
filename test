

// System Imports: Required for process handling, UI Automation, and threading.
using System.Diagnostics;
using System.Windows.Automation;
using System.Threading;
using System;

namespace PerplexityHookPoC
{
    /// <summary>
    /// This program is a Proof-of-Concept (PoC) testbed based on the 'MCP Super Assistant'
    /// technical architecture. It demonstrates how to hook into the Perplexity Windows application
    /// using the .NET UI Automation (UIA) library.
    /// 
    /// Key responsibilities, reflecting the 'Application Hooking Module' concept:
    /// 1. Find the running Perplexity process.
    /// 2. Identify key UI elements within the application window.
    /// 3. Extract text data from these elements.
    /// 4. Display the extracted data in the console.
    /// </summary>
    class Program
    {
        // Constants for targeting the Perplexity application.
        // NOTE: These values are based on the architecture document's proposal.
        // The actual values, especially AutomationId, may differ and should be verified
        // using the 'Inspect.exe' tool (part of the Windows SDK).
        private const string ProcessName = "Perplexity";
        private const string InputElementName = "Ask anything...";
        private const string AnswerAreaAutomationId = "answer-display-area"; // This is a placeholder ID.

        static void Main(string[] args)
        {
            Console.WriteLine("--- MCP Super Assistant: Perplexity Hooking PoC ---");
            Console.WriteLine($"Attempting to connect to process: '{ProcessName}'...");

            // Find the main window element of the Perplexity application.
            var perplexityWindow = FindPerplexityWindowElement();
            if (perplexityWindow == null)
            {
                Console.ForegroundColor = ConsoleColor.Red;
                Console.WriteLine($"Error: Process '{ProcessName}' not found or has no main window. Please ensure the app is running.");
                Console.ResetColor();
                Console.WriteLine("Press any key to exit.");
                Console.ReadKey();
                return;
            }

            Console.ForegroundColor = ConsoleColor.Green;
            Console.WriteLine("Successfully connected to the Perplexity application window.");
            Console.ResetColor();
            Console.WriteLine("Starting to monitor UI elements... (Press Ctrl+C to stop)");

            // Start a continuous loop to poll for UI element text changes.
            // For a production application, using UIA events (e.g., AutomationPropertyChangedEvent)
            // is more efficient than polling, as recommended in the architecture document.
            while (true)
            {
                MonitorAndExtractData(perplexityWindow);
                // Wait for 5 seconds before the next check to reduce CPU usage.
                Thread.Sleep(5000);
            }
        }

        /// <summary>
        /// Finds the main window AutomationElement for the target process.
        /// This is the entry point for all subsequent UI tree navigation.
        /// </summary>
        /// <returns>The root AutomationElement of the application's main window, or null if not found.</returns>
        private static AutomationElement FindPerplexityWindowElement()
        {
            Process[] processes = Process.GetProcessesByName(ProcessName);
            if (processes.Length == 0)
            {
                return null; // Process not found.
            }

            // Assume the first process found is the correct one.
            IntPtr mainWindowHandle = processes[0].MainWindowHandle;
            if (mainWindowHandle == IntPtr.Zero)
            {
                return null; // Process has no UI.
            }

            return AutomationElement.FromHandle(mainWindowHandle);
        }
        
        /// <summary>
        /// Periodically finds the input and answer elements and extracts their text.
        /// </summary>
        /// <param name="rootElement">The root element of the Perplexity window.</param>
        private static void MonitorAndExtractData(AutomationElement rootElement)
        {
            Console.WriteLine("\n-------------------------------------------------");
            Console.WriteLine($"[{DateTime.Now.ToString("T")}] Checking for UI element data...");

            // 1. Find the Question Input Element
            // We use a PropertyCondition to define what we're looking for.
            // Here, we search by the element's 'Name' property.
            var inputCondition = new PropertyCondition(AutomationElement.NameProperty, InputElementName);
            var inputElement = rootElement.FindFirst(TreeScope.Descendants, inputCondition);

            if (inputElement != null)
            {
                string inputText = GetElementText(inputElement);
                Console.ForegroundColor = ConsoleColor.Cyan;
                Console.WriteLine($"[Input Box] Found. Current Text:");
                Console.ResetColor();
                Console.WriteLine(string.IsNullOrEmpty(inputText) ? "[Empty]" : inputText);
            }
            else
            {
                Console.ForegroundColor = ConsoleColor.Yellow;
                Console.WriteLine($"[Input Box] Could not be found with Name='{InputElementName}'. It might not be visible or the identifier is incorrect.");
                Console.ResetColor();
            }

            // 2. Find the Answer Display Area Element
            // For this, we attempt to use 'AutomationId', as proposed in the architecture.
            // This is more reliable than 'Name' if developers set it.
            // NOTE: This is a placeholder and likely needs to be discovered with Inspect.exe.
            // var answerCondition = new PropertyCondition(AutomationElement.AutomationIdProperty, AnswerAreaAutomationId);
            // var answerElement = rootElement.FindFirst(TreeScope.Descendants, answerCondition);
            
            // As a fallback or alternative for this PoC, we can try to find an element that contains "Answer".
            // Let's try to locate the container of all messages instead. A common control type for this is a Pane.
            var paneCondition = new PropertyCondition(AutomationElement.ControlTypeProperty, ControlType.Pane);
            var allPanes = rootElement.FindAll(TreeScope.Descendants, paneCondition);
            
            AutomationElement answerElement = null;
            // A simple heuristic: find the last major pane that is not the input area. This is fragile.
            if(allPanes.Count > 1) {
                // Heuristically pick one of the panes. This requires inspection with Spy++ or similar tools.
                // For this PoC, let's just log that we found panes.
                answerElement = allPanes[allPanes.Count -1]; // Example: last pane
            }


            if (answerElement != null)
            {
                string answerText = GetElementText(answerElement);
                Console.ForegroundColor = ConsoleColor.Cyan;
                Console.WriteLine($"[Answer Area] Found. Current Text:");
                Console.ResetColor();
                Console.WriteLine(string.IsNullOrEmpty(answerText) ? "[Empty or no text pattern]" : answerText);
            }
            else
            {
                Console.ForegroundColor = ConsoleColor.Yellow;
                Console.WriteLine($"[Answer Area] Could not be found. The strategy for finding this element needs refinement (e.g., using a correct AutomationId). Found {allPanes.Count} panes.");
                Console.ResetColor();
            }
        }


        /// <summary>
        /// Extracts the text from a given UI element using its ValuePattern.
        /// The ValuePattern is common for elements like text boxes, documents, and other controls
        /// that have a string value.
        /// </summary>
        /// <param name="element">The AutomationElement to extract text from.</param>
        /// <returns>The text content of the element, or an empty string if not available.</returns>
        private static string GetElementText(AutomationElement element)
        {
            // Attempt to get the ValuePattern from the element.
            if (element.TryGetCurrentPattern(ValuePattern.Pattern, out object patternObj))
            {
                ValuePattern valuePattern = (ValuePattern)patternObj;
                return valuePattern.Current.Value;
            }

            // If ValuePattern is not available, try the TextPattern (for document-like controls).
            if (element.TryGetCurrentPattern(TextPattern.Pattern, out object textPatternObj))
            {
                TextPattern textPattern = (TextPattern)textPatternObj;
                return textPattern.DocumentRange.GetText(-1).Trim();
            }

            // Return empty if no suitable pattern is found.
            return string.Empty;
        }
    }
}

